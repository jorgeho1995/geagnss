"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitStream = exports.BitView = void 0;
class BitView {
    constructor(buffer, byteOffset = 0, byteLength = buffer.length - byteOffset) {
        this.getBoolean = (offset) => this.getBit(offset) === 1;
        this.getInt8 = (offset) => this.getBits(offset, 8, true);
        this.getUint8 = (offset) => this.getBits(offset, 8, false);
        this.getInt16 = (offset) => this.getBits(offset, 16, true);
        this.getUint16 = (offset) => this.getBits(offset, 16, false);
        this.getInt32 = (offset) => this.getBits(offset, 32, true);
        this.getUint32 = (offset) => this.getBits(offset, 32, false);
        this.setBoolean = (offset, value) => this.setBit(offset, value ? 1 : 0);
        this.setInt8 = (offset, value) => this.setBits(offset, value, 8);
        this.setUint8 = (offset, value) => this.setBits(offset, value, 8);
        this.setInt16 = (offset, value) => this.setBits(offset, value, 16);
        this.setUint16 = (offset, value) => this.setBits(offset, value, 16);
        this.setInt32 = (offset, value) => this.setBits(offset, value, 32);
        this.setUint32 = (offset, value) => this.setBits(offset, value, 32);
        this.buffer = (byteOffset === 0 && byteLength === buffer.length)
            ? buffer : buffer.subarray(byteOffset, byteOffset + byteLength);
        this.byteLength = byteLength;
        this.bitLength = byteLength * 8;
    }
    checkBounds(offset, bits) {
        const available = (this.bitLength - offset);
        if (bits > available)
            throw new Error('Cannot get/set ' + bits + ' bit(s) from offset ' + offset + ', ' + available + ' available');
    }
    getBit(offset) {
        return (this.buffer[offset >> 3] >> (7 - (offset & 0b111)) & 0b1);
    }
    getBits(offset, bits, signed) {
        this.checkBounds(offset, bits);
        const startBitOffset = offset & 0b111;
        const endBitOffset = 8 - ((offset + bits) & 0b111 || 8);
        const startByte = offset >> 3;
        const endByte = (offset + bits - 1) >> 3;
        let value = 0;
        let written = 0;
        for (let i = startByte; i <= endByte; i++) {
            let byte = this.buffer[i];
            let shift = 8;
            if (i === startByte) {
                byte &= 0b11111111 >> startBitOffset;
                shift -= startBitOffset;
            }
            if (i === endByte) {
                byte >>= endBitOffset;
                shift -= endBitOffset;
            }
            written += shift;
            if (i !== startByte) {
                if (written <= 32)
                    value <<= shift;
                else
                    value *= 2 ** shift;
            }
            if (written <= 32)
                value |= byte;
            else
                value += byte;
            if (!signed && written === 32)
                value >>>= 0;
        }
        if (signed) {
            if (bits < 32 && value >> (bits - 1) > 0) {
                value |= -1 ^ ((1 << bits) - 1);
            }
            else if (bits > 32 && value > 2 ** (bits - 1)) {
                value -= 2 ** bits;
            }
        }
        return value;
    }
    getBitArray(offset, bits) {
        this.checkBounds(offset, bits);
        const result = [];
        for (let i = 0; i < bits; i++, offset++) {
            result[i] = (this.buffer[offset >> 3] >> (7 - (offset & 0b111)) & 0b1) === 1;
        }
        return result;
    }
    setBit(offset, value) {
        if (value === 1)
            this.buffer[offset >> 3] |= 0b10000000 >> (offset & 0b111);
        else
            this.buffer[offset >> 3] &= ~(0b10000000 >> (offset & 0b111));
    }
    setBits(offset, value, bits) {
        this.checkBounds(offset, bits);
        const startBitOffset = offset & 0b111;
        const endBitOffset = 8 - ((offset + bits) & 0b111 || 8);
        const startByte = offset >> 3;
        const endByte = (offset + bits - 1) >> 3;
        for (let i = endByte; i >= startByte; i--) {
            let read = 8;
            let shift = 0;
            let mask = 0b11111111;
            if (i === startByte) {
                read -= startBitOffset;
                mask &= 0b11111111 >> startBitOffset;
            }
            if (i === endByte) {
                read -= endBitOffset;
                mask &= 0b11111111 << endBitOffset;
                shift = endBitOffset;
            }
            let byte;
            if (bits <= 32) {
                byte = value & (0b11111111 >> (8 - read));
                value >>= read;
            }
            else {
                const divisor = 2 ** read;
                byte = value % divisor;
                if (byte < 0)
                    byte += divisor;
                value = (value - byte) / divisor;
            }
            bits -= read;
            this.buffer[i] = (this.buffer[i] & ~mask) | (byte << shift);
        }
    }
    setBitArray(offset, values, bits = values.length) {
        this.checkBounds(offset, bits);
        for (let i = 0; i < bits; i++, offset++) {
            if (values[i])
                this.buffer[offset >> 3] |= 0b10000000 >> (offset & 0b111);
            else
                this.buffer[offset >> 3] &= ~(0b10000000 >> (offset & 0b111));
        }
    }
    readBuffer(offset, byteLength) {
        const buffer = new Uint8Array(byteLength);
        for (let i = 0; i < byteLength; i++)
            buffer[i] = this.getUint8(offset + (i * 8));
        return buffer;
    }
    writeBuffer(offset, buffer) {
        for (let i = 0; i < buffer.length; i++)
            this.setUint8(offset + (i * 8), buffer[i]);
        return buffer.length;
    }
    readString(offset, byteLength, decoder = new TextDecoder()) {
        return decoder.decode(this.readBuffer(offset, byteLength));
    }
    writeString(offset, string, byteLength, encoder = new TextEncoder()) {
        let buffer;
        if (byteLength === undefined) {
            buffer = encoder.encode(string);
        }
        else {
            buffer = new Uint8Array(byteLength);
            encoder.encodeInto(string, buffer);
        }
        this.writeBuffer(offset, buffer);
        return buffer.length;
    }
}
exports.BitView = BitView;
class BitStream {
    constructor(source, byteOffset, byteLength) {
        this.readBoolean = () => this.readBit() === 1;
        this.readInt8 = () => this.readBits(8, true);
        this.readUint8 = () => this.readBits(8, false);
        this.readInt16 = () => this.readBits(16, true);
        this.readUint16 = () => this.readBits(16, false);
        this.readInt32 = () => this.readBits(32, true);
        this.readUint32 = () => this.readBits(32, false);
        this.writeBoolean = (value) => this.writeBit(value ? 1 : 0);
        this.writeInt8 = (value) => this.writeBits(value, 8);
        this.writeUint8 = (value) => this.writeBits(value, 8);
        this.writeInt16 = (value) => this.writeBits(value, 16);
        this.writeUint16 = (value) => this.writeBits(value, 16);
        this.writeInt32 = (value) => this.writeBits(value, 32);
        this.writeUint32 = (value) => this.writeBits(value, 32);
        this.view = source instanceof BitView ? source : new BitView(source, byteOffset, byteLength);
        this.buffer = this.view.buffer;
        this.bitIndex = 0;
        this.bitLength = this.view.bitLength;
        this.byteLength = this.view.byteLength;
    }
    get index() { return this.bitIndex; }
    set index(val) { this.bitIndex = val; }
    ;
    get bitsLeft() { return this.bitLength - this.bitIndex; }
    get byteIndex() { return Math.ceil(this.bitIndex / 8); }
    set byteIndex(val) { this.bitIndex = val * 8; }
    readBit() {
        const val = this.view.getBit(this.bitIndex);
        this.bitIndex++;
        return val;
    }
    readBits(bits, signed = false) {
        const val = this.view.getBits(this.bitIndex, bits, signed);
        this.bitIndex += bits;
        return val;
    }
    readBitArray(bits) {
        const val = this.view.getBitArray(this.bitIndex, bits);
        this.bitIndex += bits;
        return val;
    }
    writeBit(value) {
        this.view.setBit(this.bitIndex, value);
        this.bitIndex++;
    }
    writeBits(value, bits) {
        this.view.setBits(this.bitIndex, value, bits);
        this.bitIndex += bits;
    }
    writeBitArray(values, bits = values.length) {
        this.view.setBitArray(this.bitIndex, values, bits);
        this.bitIndex += bits;
    }
    readBuffer(byteLength) {
        const buffer = this.view.readBuffer(this.bitIndex, byteLength);
        this.bitIndex += byteLength * 8;
        return buffer;
    }
    writeBuffer(buffer) {
        const length = this.view.writeBuffer(this.bitIndex, buffer);
        this.bitIndex += buffer.length * 8;
        return length;
    }
    readString(byteLength, decoder) {
        const string = this.view.readString(this.bitIndex, byteLength, decoder);
        this.bitIndex += byteLength * 8;
        return string;
    }
    writeString(string, byteLength, encoder) {
        const length = this.view.writeString(this.bitIndex, string, byteLength, encoder);
        this.bitIndex += length * 8;
        return length;
    }
}
exports.BitStream = BitStream;
