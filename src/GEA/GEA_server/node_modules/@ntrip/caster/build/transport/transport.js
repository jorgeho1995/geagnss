"use strict";
/*
 * This file is part of the @ntrip/caster distribution (https://github.com/node-ntrip/caster).
 * Copyright (c) 2020 Nebojsa Cvetkovic.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingleConnectionTransport = exports.Transport = void 0;
const events = require("events");
class Transport extends events.EventEmitter {
    /**
     * Constructs a new NTRIP transport
     *
     * @param caster NTRIP manager that initiated this transport
     * @param options Options for subclasses
     */
    constructor(caster, options) {
        super();
        this.caster = caster;
        this._connections = new Set();
    }
    get connections() { return this._connections; }
    ;
    /** Closes any established servers and existing connections */
    close() {
        this._connections.forEach((connection) => connection.close());
    }
    error(error) {
        this.emit('error', error);
        this.close();
    }
    /**
     * Makes a connection to the caster
     *
     * @param params Caster connection parameters, excluding transport
     * @throws TODO
     */
    connect(params) {
        const connection = this.caster.connect({ ...params, transport: this });
        this._connections.add(connection);
        connection.once('close', () => this._connections.delete(connection));
        return connection;
    }
    /** Returns a description of a specific connection from this transport for use in logging */
    connectionDescription(source) {
        return source.toString();
    }
}
exports.Transport = Transport;
class SingleConnectionTransport extends Transport {
    constructor() {
        super(...arguments);
        this.closeWrapper = () => this.close();
    }
    get connection() { return this._connection; }
    connect(params) {
        const connection = super.connect(params);
        connection === null || connection === void 0 ? void 0 : connection.once('close', this.closeWrapper);
        this._connection = connection;
        return connection;
    }
    close() {
        var _a;
        (_a = this._connection) === null || _a === void 0 ? void 0 : _a.off('close', this.closeWrapper);
        this._connection = undefined;
        super.close();
    }
}
exports.SingleConnectionTransport = SingleConnectionTransport;
