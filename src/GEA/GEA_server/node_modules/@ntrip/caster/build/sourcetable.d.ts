export declare namespace Sourcetable {
    /**
     * An entry in the caster sourcetable
     *
     * Provides helper methods for filtering sourcetable entries and generating sourcetable text lines.
     */
    export abstract class Entry {
        /** The sourcetable entry type as 3 characters e.g. STR, CAS, NET */
        get entryType(): string;
        /**
         * Returns the entry as a sourcetable text line
         */
        toSourcetableLine(): string;
        /**
         * Returns a list of elements included in the entry's sourcetable text line
         */
        toSourcetableLineElements(): Element[];
        /**
         * Returns a list of elements included in the entry's sourcetable text line in their raw form
         *
         * Same as {@link #toSourcetableLineElements} but without elements converted to strings and numbers
         */
        abstract toRawSourcetableLineElements(): any[];
        /**
         * Parses the provided sourcetable text line and updates fields in this entry
         *
         * @param line Sourcetable text line
         */
        fromSourcetableLine(line: string): void;
        /**
         * Updates the entry's elements based on the provided list of elements
         */
        fromSourcetableLineElements(elements: string[]): void;
        /**
         * Updates the entry's elements based on the provided list of elements in their raw form
         *
         * Same as {@link #fromSourcetableLineElements} but with elements converted from strings and numbers
         */
        abstract fromRawSourcetableLineElements(elements: any[]): void;
        static destructureElementsFromLine(elements: string[], destructuringConversions: (null | ((s: string) => any))[]): any[];
        static structureElementsToLine(elements: any[], structuringConversions: (null | ((e: any) => Element))[]): Element[];
        /**
         * Filter this source entry by simple and advanced element filtering
         *
         * @param filters Filter lists
         * @param simple Whether a simple search is being performed
         * @param strict Whether to throw errors when an invalid condition is found
         */
        filter(filters: AdvancedFilterList[], simple: boolean, strict?: boolean): boolean;
        /**
         * Filters this source entry based on its elements
         *
         * @param filters List of filters for each element
         * @param simple Whether a simple search is being performed
         * @param strict Whether to throw errors when an invalid condition is found
         */
        private filterElements;
        /**
         * Parses the provided sourcetable text line and returns a corresponding sourcetable entry object
         *
         * @param line Sourcetable text line
         */
        static parseSourcetableLine(line: string): Entry | Error;
    }
    export class SourceEntry extends Entry {
        mountpoint: string;
        identifier?: string;
        format?: Sourcetable.Format | string;
        formatDetails?: {
            type: string | number;
            rate?: number;
        }[] | string[] | string;
        carrier?: Sourcetable.CarrierPhaseInformation | number;
        navSystem?: (Sourcetable.NavSystem | string)[];
        network?: string;
        country?: string;
        latitude?: number;
        longitude?: number;
        nmea?: boolean;
        solution?: Sourcetable.SolutionType | number;
        generator?: string;
        compressionEncryption?: string;
        authentication?: Sourcetable.AuthenticationMode | string;
        fee?: boolean;
        bitrate?: number;
        misc?: string[];
        static readonly ENTRY_TYPE = "STR";
        static readonly DESTRUCTURING_CONVERSIONS: (null | ((s: string) => any))[];
        static readonly STRUCTURING_CONVERSIONS: (null | ((e: any) => string | number | undefined))[];
        constructor(mountpoint: string);
        fromRawSourcetableLineElements(elements: any[]): void;
        toRawSourcetableLineElements(): any[];
    }
    export class CasterEntry extends Entry {
        host: string;
        port: number;
        identifier?: string;
        operator?: string;
        nmea?: Sourcetable.SolutionType | number;
        country?: string;
        latitude?: number;
        longitude?: number;
        fallback_host?: string;
        fallback_port?: number;
        misc?: string[];
        static readonly ENTRY_TYPE = "CAS";
        static readonly DESTRUCTURING_CONVERSIONS: (null | ((s: string) => any))[];
        static readonly STRUCTURING_CONVERSIONS: (null | ((e: any) => string | number | undefined))[];
        constructor(host: string, port: number);
        fromRawSourcetableLineElements(elements: any[]): void;
        toRawSourcetableLineElements(): any[];
    }
    export class NetworkEntry extends Entry {
        identifier: string;
        operator?: string;
        authentication?: Sourcetable.AuthenticationMode | string;
        fee?: boolean;
        webNetwork?: string;
        webStream?: string;
        webRegistration?: string;
        misc?: string[];
        static readonly ENTRY_TYPE = "NET";
        static readonly DESTRUCTURING_CONVERSIONS: (null | ((s: string) => any))[];
        static readonly STRUCTURING_CONVERSIONS: (null | ((e: any) => string | number | undefined))[];
        constructor(identifier: string);
        fromRawSourcetableLineElements(elements: any[]): void;
        toRawSourcetableLineElements(): any[];
    }
    type Element = string | number | undefined;
    export type SimpleFilter = string | undefined;
    export type SimpleFilterList = SimpleFilter[];
    export type AdvancedFilter = SimpleFilter | number | {
        string: RegExp | Error;
        number: (NumberFilter | Error)[][] | Error;
    };
    export type AdvancedFilterList = AdvancedFilter[];
    class NumberFilter {
        private readonly negate;
        private readonly comparator;
        private readonly value;
        constructor(negate: boolean, comparator: '=' | '>' | '<' | '>=' | '<=', value: number);
        test(input: number): boolean;
        private compare;
    }
    /**
     * Filters applicable when requesting sourcetable entries
     */
    export interface Filters {
        /** Authentication request to only include entries which user has access to */
        auth?: boolean;
        /** Whether to throw errors when an invalid condition is found */
        strict?: boolean;
        /** Simple (direct text match based) filter lists */
        simple?: SimpleFilterList[];
        /** Advanced filter lists */
        advanced?: AdvancedFilterList[];
    }
    /**
     * Parses advanced NTRIP filters
     *
     * Converts filters from string form to RegExp/number matcher or simplified string form.
     *
     * Used to process filters that were passed in by the user during sourcetable GET request.
     *
     * @param filters Parsed advanced filter list
     */
    export function parseAdvancedFilters(filters: (string | undefined)[]): AdvancedFilterList;
    /**
     * Performs filtering of sourcetable for approximation filters (closest values)
     *
     * Allows user to provide one or more values for which the closest matching entries are to be returned.
     *
     * For example, user could request nearest servers by lat/lng with STR;;;;;;;;~53.1;~-7.6.
     *
     * A score is calculated for each entry as the sum of the distances of its elements to the target values.
     *
     * Multiple values can be provided for a given field to allow for multiple simultaneous filters, and each is
     * added to the cumulative score for each entry.
     *
     * @param filters Array of numbers at entry element indices to approximate
     * @param entries List of entries to filter
     * @param strict Whether to throw an error if a non numeric element is encountered in an entry when expected
     * @return Filtered list of entries containing the entries closest to the request values
     */
    export function filterApproximations(filters: AdvancedFilterList[], entries: Entry[], strict?: boolean): Entry[];
    export enum Format {
        BINEX = "BINEX",
        CMR = "CMR",
        NMEA = "NMEA",
        RAW = "RAW",
        RTCA = "RTCA",
        RTCM_2 = "RTCM 2",
        RTCM_2_1 = "RTCM 2.1",
        RTCM_2_2 = "RTCM 2.2",
        RTCM_2_3 = "RTCM 2.3",
        RTCM_3 = "RTCM 3",
        RTCM_3_0 = "RTCM 3.0",
        RTCM_3_1 = "RTCM 3.1",
        RTCM_3_2 = "RTCM 3.2",
        RTCM_3_3 = "RTCM 3.3",
        RTCM_SAPOS = "RTCM SAPOS"
    }
    export enum NavSystem {
        GPS = "GPS",
        GLONASS = "GLO",
        GALILEO = "GAL",
        BEIDOU = "BDS",
        QZSS = "QZS",
        SBAS = "SBAS",
        IRNSS = "IRS"
    }
    export enum SolutionType {
        SingleBase = 0,
        Network = 1
    }
    export enum AuthenticationMode {
        None = "N",
        Basic = "B",
        Digest = "D"
    }
    export enum CarrierPhaseInformation {
        None = 0,
        L1 = 1,
        L1_L2 = 2
    }
    export {};
}
