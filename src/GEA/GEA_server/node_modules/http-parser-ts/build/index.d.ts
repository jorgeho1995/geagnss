/// <reference types="node" />
declare const kOnHeaders = 0;
declare const kOnHeadersComplete = 1;
declare const kOnBody = 2;
declare const kOnMessageComplete = 3;
declare const kOnExecute = 4;
export declare const methods: string[];
export declare class HTTPParser {
    /**
     * Binds the custom parser, must be run before the 'http' module is imported
     */
    static bind(): void;
    /**
     * Checks if the parser was successfully bound, otherwise throws an exception
     */
    static verify(): void;
    static readonly REQUEST = "REQUEST";
    static readonly RESPONSE = "RESPONSE";
    static encoding: BufferEncoding;
    static maxHeaderSize: number;
    static readonly kOnHeaders = 0;
    static readonly kOnHeadersComplete = 1;
    static readonly kOnBody = 2;
    static readonly kOnMessageComplete = 3;
    static readonly kOnExecute = 4;
    static readonly methods: string[];
    protected static readonly HEADER_STATES: string[];
    protected static readonly FINISH_STATES: string[];
    protected type: typeof HTTPParser.REQUEST | typeof HTTPParser.RESPONSE;
    protected state?: 'REQUEST_LINE' | 'RESPONSE_LINE' | 'HEADER' | 'BODY_CHUNK' | 'BODY_CHUNKHEAD' | 'BODY_CHUNKEND' | 'BODY_CHUNKTRAILERS' | 'BODY_SIZED' | 'BODY_RAW';
    protected info: {
        method?: number;
        url?: string;
        statusCode?: number;
        statusMessage?: string;
        versionMajor?: number;
        versionMinor?: number;
        headers: string[];
        trailers: string[];
        upgrade: boolean;
        connection?: string;
        shouldKeepAlive?: boolean;
    };
    protected chunk: Buffer | null;
    protected offset: number;
    protected length: number;
    protected line: string;
    protected isChunked: boolean;
    protected headerSize: number;
    protected bodyBytes: number | null;
    protected hadError: boolean;
    constructor();
    initialize(type: typeof HTTPParser.REQUEST | typeof HTTPParser.RESPONSE): void;
    [kOnHeaders]: (headers: string[], url: string) => void;
    [kOnHeadersComplete]: (versionMajor: number, versionMinor: number, headers: string[], method: number, url: string, statusCode: number, statusMessage: string, upgrade: boolean, shouldKeepAlive: boolean) => number;
    [kOnBody]: (buffer: Buffer, start: number, length: number) => void;
    [kOnMessageComplete]: () => void;
    [kOnExecute]: () => void;
    close(): void;
    free(): void;
    pause(): void;
    resume(): void;
    _consumed: boolean;
    consume(handle: any): void;
    unconsume(): void;
    getCurrentBuffer(): void;
    execute(chunk: Buffer): number | ParseError;
    finish(): ParseError | undefined;
    protected nextRequest(): void;
    protected consumeLine(): string | undefined;
    protected static readonly HEADER_REGEX: RegExp;
    protected static readonly HEADER_CONTINUE_REGEX: RegExp;
    protected parseHeader(line: string, headers: string[]): void;
    protected static readonly REQUEST_REGEX: RegExp;
    protected REQUEST_LINE(): void;
    protected static readonly RESPONSE_REGEX: RegExp;
    protected RESPONSE_LINE(): void;
    protected shouldKeepAlive(): boolean;
    protected HEADER(): boolean | void;
    protected BODY_CHUNKHEAD(): void;
    protected BODY_CHUNK(): void;
    protected BODY_CHUNKEND(): void;
    protected BODY_CHUNKTRAILERS(): void;
    protected BODY_RAW(): void;
    protected BODY_SIZED(): void;
}
export declare class ParseError extends Error {
    readonly code: string;
    constructor(code: string, reason?: string);
}
export {};
