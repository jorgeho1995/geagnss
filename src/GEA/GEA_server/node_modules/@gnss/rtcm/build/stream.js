"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RtcmEncodeTransformStream = exports.RtcmDecodeTransformStream = void 0;
const stream = require("stream");
const rtcm_1 = require("./rtcm");
class RtcmDecodeTransformStream extends stream.Transform {
    constructor({ closeOnError = true, synchronizedInitially = false } = {}) {
        super({
            readableObjectMode: true
        });
        this.buffer = Buffer.allocUnsafe(rtcm_1.RtcmTransport.MAX_PACKET_SIZE);
        this.index = 0;
        this.synchronized = false;
        this.potential = false;
        this.closeOnError = false;
        this.closeOnError = closeOnError;
        this.synchronized = synchronizedInitially;
    }
    _transform(chunk, encoding, callback) {
        if (typeof chunk === 'string')
            chunk = Buffer.from(chunk, encoding);
        let chunkOffset = 0;
        while (chunk.length - chunkOffset > 0) {
            if (!this.potential && !this.synchronized) {
                const potential = chunk.indexOf(rtcm_1.RtcmTransport.SYNC_CHAR, chunkOffset);
                if (potential < 0)
                    return callback();
                this.potential = true;
                chunkOffset = potential;
            }
            const copyBytes = Math.min(chunk.length - chunkOffset, this.buffer.length - this.index);
            chunk.copy(this.buffer, this.index, chunkOffset, chunkOffset + copyBytes);
            this.index += copyBytes;
            chunkOffset += copyBytes;
            do {
                let message;
                let packetLength;
                try {
                    if (this.buffer[0] !== rtcm_1.RtcmTransport.SYNC_CHAR)
                        rtcm_1.RtcmTransport.decode(this.buffer);
                    if (this.index < rtcm_1.RtcmTransport.HEADER_SIZE)
                        break;
                    const messageLength = (this.buffer[1] & 0x03) << 8 | this.buffer[2];
                    packetLength = messageLength + rtcm_1.RtcmTransport.HEADER_SIZE + rtcm_1.RtcmTransport.CRC_SIZE;
                    if (this.index < packetLength)
                        break;
                    [message] = rtcm_1.RtcmTransport.decode(this.buffer);
                }
                catch (err) {
                    if (this.synchronized && this.closeOnError)
                        return callback(err);
                    this.synchronized = false;
                    this.potential = false;
                    const potential = this.buffer.indexOf(rtcm_1.RtcmTransport.SYNC_CHAR, 1);
                    if (potential < 0 || potential >= this.index) {
                        this.index = 0;
                        break;
                    }
                    this.potential = true;
                    this.buffer.copyWithin(0, potential);
                    this.index -= potential;
                    continue;
                }
                this.potential = false;
                this.synchronized = true;
                this.buffer.copyWithin(0, packetLength);
                this.index -= packetLength;
                this.push(message);
                break;
            } while (true);
        }
        return callback();
    }
}
exports.RtcmDecodeTransformStream = RtcmDecodeTransformStream;
class RtcmEncodeTransformStream extends stream.Transform {
    constructor() {
        super({
            writableObjectMode: true
        });
        this.buffer = Buffer.allocUnsafe(rtcm_1.RtcmTransport.MAX_PACKET_SIZE);
    }
    _transform(chunk, encoding, callback) {
        try {
            const length = rtcm_1.RtcmTransport.encode(chunk, this.buffer);
            callback(null, this.buffer.slice(0, length));
        }
        catch (err) {
            callback(err);
        }
    }
}
exports.RtcmEncodeTransformStream = RtcmEncodeTransformStream;
