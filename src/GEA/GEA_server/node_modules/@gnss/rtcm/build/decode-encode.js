"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DF = exports.CustomEncoder = exports.CustomDecoder = exports.Skip = exports.IfInstanceOf = exports.If = exports.ArrLength = exports.Arr = exports.Obj = exports.Utf8 = exports.Latin1 = exports.Bool = exports.IntSM = exports.UInt = exports.Int = exports.getDecoderEncoder = exports.DecoderEncoder = void 0;
require("reflect-metadata");
const util_1 = require("util");
class Coder {
    constructor(parent) {
        this.parent = parent;
        this.definitions = Coder.definitions;
        this.lines = [];
    }
    static define(definition) {
        return `this.definitions[${Coder.definitions.push(definition) - 1}]`;
    }
    code(...code) {
        this.lines.push(...code);
    }
    set(prop, code) {
        this.code(`o.${prop} = ${code}`);
    }
    get fullLines() {
        var _a, _b;
        return [...(_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.fullLines) !== null && _b !== void 0 ? _b : [], ...this.lines];
    }
    get fullScript() {
        return this.fullLines.join('\n') + '\n';
    }
    run(o, s) {
        var _a;
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.run(o, s);
        if (this.compiled === undefined)
            this.compiled = new Function('o', 's', this.lines.join('\n'));
        this.compiled(o, s);
        return o;
    }
}
Coder.definitions = [];
class DecoderEncoder {
    constructor(parent) {
        this.parent = parent;
        this.unsigned = (prop, bits) => this.number(prop, false, bits);
        this.signed = (prop, bits) => this.number(prop, true, bits);
        this.encoder = new Coder(parent === null || parent === void 0 ? void 0 : parent.encoder);
        this.decoder = new Coder(parent === null || parent === void 0 ? void 0 : parent.decoder);
    }
    skip(bits) {
        this.decoder.code(`s.index += ${bits};`);
        this.encoder.code(`s.writeBits(0, ${bits});`);
    }
    array(prop, count) {
        let length = typeof count === 'number' ? count : `o.${count}`;
        this.decoder.set(prop, `[]`);
        this.decoder.code(`for (let i = 0; i < ${length}; i++)`);
        this.encoder.code(`if (o.${prop}.length !== ${length})`, `\tthrow new Error("Incorrect number of elements in " + o.constructor.name + "['${prop}']: " + o.${prop}.length + " found, " + ${length} + " expected (max)");`);
        this.encoder.code(`for (let i = 0; i < ${length}; i++)`);
    }
    arrayLength(prop, bits, arrayProp) {
        this.encoder.set(prop, `Math.min(o.${arrayProp}.length, ${2 ** bits})`);
        this.unsigned(prop, bits);
    }
    object(prop, constructor) {
        const ode = getDecoderEncoder(constructor);
        const constructorDef = Coder.define(constructor);
        const odeDef = Coder.define(ode);
        this.decoder.set(prop, `${odeDef}.decoder.run(new ${constructorDef}(), s);`);
        this.encoder.code(`${odeDef}.encoder.run(o.${prop}, s);`);
    }
    customDecoder(method) {
        this.decoder.code(`o.${method}(s);`);
    }
    customEncoder(method) {
        this.encoder.code(`o.${method}(s);`);
    }
    if(prop) {
        this.decoder.code(`if (o.${prop})`);
        this.encoder.code(`if (o.${prop})`);
    }
    ifInstanceOf(constructor) {
        const constructorDef = Coder.define(constructor);
        this.decoder.code(`if (o instanceof ${constructorDef}())`);
        this.encoder.code(`if (o instanceof ${constructorDef}())`);
    }
    number(prop, signed, bits) {
        this.decoder.set(prop, `s.readBits(${bits}, ${signed});`);
        this.encoder.code(`s.writeBits(o.${prop}, ${bits});`);
    }
    numberSignMagnitude(prop, bits) {
        this.decoder.set(prop, `(s.readBoolean() ? -1 : 1) * s.readBits(${bits - 1});`);
        this.encoder.code(`s.writeBits(Math.abs(o.${prop}) | (o.${prop} < 0 ? (1 << ${bits - 1}) : 0), ${bits});`);
    }
    boolean(prop) {
        this.decoder.set(prop, 's.readBoolean();');
        this.encoder.code(`s.writeBoolean(o.${prop});`);
    }
    latin1(prop, lengthBits) {
        this.decoder.set(prop, `s.readString(s.readBits(${lengthBits}), ${DecoderEncoder.latin1Decoder});`);
        this.encoder.code(`{`, `\ts.writeBits(o.${prop}.length, ${lengthBits});`, `\tfor (let i = 0; i < o.${prop}.length; i++) {`, `\t\tconst cp = o.${prop}.codePointAt(i);`, `\t\tif (cp > 255)`, `\t\t\tthrow new Error("Invalid latin1 codepoint " + cp);`, `\ts.writeUint8(cp);`, `\t}`, `}`);
    }
    utf8(prop, charactersBits, lengthBits) {
        this.decoder.code('{', `\ts.index += ${charactersBits};`, `\to.${prop} = s.readString(s.readBits(${lengthBits}), ${DecoderEncoder.utf8Decoder});`, '}');
        this.encoder.code('{', `\tlet encoded = ${DecoderEncoder.utf8Encoder}.encode(o.${prop});`, `\ts.writeBits(o.${prop}.length, ${charactersBits});`, `\ts.writeBits(encoded.length, ${lengthBits});`, `\ts.writeBuffer(encoded);`, '}');
    }
}
exports.DecoderEncoder = DecoderEncoder;
DecoderEncoder.utf8Decoder = Coder.define(new util_1.TextDecoder('utf8'));
DecoderEncoder.latin1Decoder = Coder.define(new util_1.TextDecoder('latin1'));
DecoderEncoder.utf8Encoder = Coder.define(new TextEncoder());
const decoderEncoderKey = Symbol('decoderEncoder');
function getDecoderEncoder(target) {
    const c = (target.hasOwnProperty('constructor') ? target.constructor : target);
    if (!Reflect.hasOwnMetadata(decoderEncoderKey, c))
        Reflect.defineMetadata(decoderEncoderKey, new DecoderEncoder(Reflect.getMetadata(decoderEncoderKey, c)), c);
    return Reflect.getMetadata(decoderEncoderKey, c);
}
exports.getDecoderEncoder = getDecoderEncoder;
function propertyDecorator(f) {
    return (target, propertyKey) => {
        f(getDecoderEncoder(target), propertyKey);
    };
}
const Int = (bits) => propertyDecorator((de, key) => de.signed(key, bits));
exports.Int = Int;
const UInt = (bits) => propertyDecorator((de, key) => de.unsigned(key, bits));
exports.UInt = UInt;
const IntSM = (bits) => propertyDecorator((de, key) => de.numberSignMagnitude(key, bits));
exports.IntSM = IntSM;
exports.Bool = propertyDecorator((de, key) => de.boolean(key));
const Latin1 = (lengthBits) => propertyDecorator((de, key) => de.latin1(key, lengthBits));
exports.Latin1 = Latin1;
const Utf8 = (charactersBits, lengthBits) => propertyDecorator((de, key) => de.utf8(key, charactersBits, lengthBits));
exports.Utf8 = Utf8;
const Obj = (constructor) => propertyDecorator((de, key) => de.object(key, constructor));
exports.Obj = Obj;
const Arr = (length, type) => (target, propertyKey) => {
    getDecoderEncoder(target).array(propertyKey, length);
    type(target, propertyKey + '[i]');
};
exports.Arr = Arr;
const ArrLength = (bits, arrayProp) => propertyDecorator((de, key) => de.arrayLength(key, bits, arrayProp));
exports.ArrLength = ArrLength;
const If = (prop) => propertyDecorator((de) => de.if(prop));
exports.If = If;
const IfInstanceOf = (constructor) => propertyDecorator((de) => de.ifInstanceOf(constructor));
exports.IfInstanceOf = IfInstanceOf;
const Skip = (bits) => propertyDecorator((de) => de.skip(bits));
exports.Skip = Skip;
exports.CustomDecoder = propertyDecorator((de, key) => de.customDecoder(key));
exports.CustomEncoder = propertyDecorator((de, key) => de.customEncoder(key));
const dfMetadataKey = Symbol('df');
const DF = (number) => Reflect.metadata(dfMetadataKey, number);
exports.DF = DF;
