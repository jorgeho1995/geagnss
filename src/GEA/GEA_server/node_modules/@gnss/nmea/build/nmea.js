"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NmeaTransport = exports.NmeaMessageQuery = exports.NmeaMessageProprietary = exports.NmeaMessageUnknown = exports.NmeaMessage = exports.Sentence = void 0;
const talkers_1 = require("./talkers");
const decode_encode_1 = require("./decode-encode");
const nmeaMessageClasses = new Map();
function Sentence(type, delimiter = NmeaTransport.SENTENCE_DELIMITER_PARAMETRIC) {
    return function (constructor) {
        Object.defineProperty(constructor, 'sentenceType', {
            value: type,
            writable: false
        });
        Object.defineProperty(constructor, 'sentenceDelimiter', {
            value: delimiter,
            writable: false
        });
        if (nmeaMessageClasses.has(type))
            throw new Error(`Class for message type ${type} is already registered`);
        nmeaMessageClasses.set(type, constructor);
    };
}
exports.Sentence = Sentence;
class NmeaMessage {
    constructor(internalGuard) { }
    get sentenceType() { return this.constructor.sentenceType; }
    get sentenceDelimiter() { return this.constructor.sentenceDelimiter; }
    static construct(params) {
        return Object.assign(new this(undefined), params);
    }
}
exports.NmeaMessage = NmeaMessage;
class NmeaMessageUnknown extends NmeaMessage {
    get sentenceType() { return this.unknownSentenceType; }
    get sentenceDelimiter() { return this.unknownSentenceDelimiter; }
}
__decorate([
    decode_encode_1.Arr('elements.length', decode_encode_1.Str),
    __metadata("design:type", Array)
], NmeaMessageUnknown.prototype, "elements", void 0);
exports.NmeaMessageUnknown = NmeaMessageUnknown;
class NmeaMessageProprietary extends NmeaMessageUnknown {
    get manufacturerMnemonic() { return this.sentenceType; }
}
exports.NmeaMessageProprietary = NmeaMessageProprietary;
class NmeaMessageQuery extends NmeaMessage {
    get sentenceType() {
        return this.queriedTalker + NmeaTransport.QUERY_ADDRESS_CHARACTER;
    }
}
__decorate([
    decode_encode_1.Str,
    __metadata("design:type", String)
], NmeaMessageQuery.prototype, "queriedSentenceType", void 0);
exports.NmeaMessageQuery = NmeaMessageQuery;
var NmeaTransport;
(function (NmeaTransport) {
    NmeaTransport.MAX_SENTENCE_SIZE = 82;
    NmeaTransport.SENTENCE_DELIMITER_PARAMETRIC = '$';
    NmeaTransport.SENTENCE_DELIMITER_ENCAPSULATION = '!';
    NmeaTransport.DATA_FIELD_DELIMITER = ',';
    NmeaTransport.CHECKSUM_FIELD_DELIMITER = '*';
    NmeaTransport.CODE_DELIMITER = '^';
    NmeaTransport.TAG_BLOCK_DELIMITER = '\\';
    NmeaTransport.RESERVED_FUTURE_USE_CHARACTERS = ['~', '\x7f'];
    NmeaTransport.SENTENCE_TERMINATION_SEQUENCE = '\r\n';
    NmeaTransport.RESERVED_CHARACTERS = [
        NmeaTransport.SENTENCE_DELIMITER_PARAMETRIC,
        NmeaTransport.SENTENCE_DELIMITER_ENCAPSULATION,
        NmeaTransport.DATA_FIELD_DELIMITER,
        NmeaTransport.CHECKSUM_FIELD_DELIMITER,
        NmeaTransport.CODE_DELIMITER,
        NmeaTransport.TAG_BLOCK_DELIMITER,
        ...NmeaTransport.RESERVED_FUTURE_USE_CHARACTERS
    ];
    NmeaTransport.QUERY_ADDRESS_CHARACTER = 'Q';
    class Exception extends Error {
        constructor(type, message) {
            super(`NMEA ${type} exception: ${message}`);
        }
    }
    NmeaTransport.Exception = Exception;
    class DecodeException extends Exception {
        constructor(message) {
            super('decode', message);
        }
    }
    NmeaTransport.DecodeException = DecodeException;
    class EncodeException extends Exception {
        constructor(message) {
            super('encode', message);
        }
    }
    NmeaTransport.EncodeException = EncodeException;
    function decode(sentence) {
        const sentenceDelimiter = sentence[0];
        if (sentenceDelimiter != NmeaTransport.SENTENCE_DELIMITER_PARAMETRIC && sentenceDelimiter != NmeaTransport.SENTENCE_DELIMITER_ENCAPSULATION)
            throw new DecodeException(`Invalid delimiter (expected ${NmeaTransport.SENTENCE_DELIMITER_PARAMETRIC} or ${NmeaTransport.SENTENCE_DELIMITER_ENCAPSULATION}, got ${sentenceDelimiter})`);
        const checksumIndex = sentence.indexOf(NmeaTransport.CHECKSUM_FIELD_DELIMITER);
        const content = sentence.substring(1, checksumIndex);
        const checksumReceived = sentence.substr(checksumIndex + 1, 2).toUpperCase();
        const checksumCalculated = checksum(content);
        if (checksumCalculated !== checksumReceived)
            throw new DecodeException(`Checksum does not match (${checksumCalculated} != ${checksumReceived})`);
        const elements = content.split(NmeaTransport.DATA_FIELD_DELIMITER);
        const address = elements[0];
        if (address.length < 4 || address.length > 5)
            throw new DecodeException(`Invalid address field length: ${address}`);
        if (address.split('').some(c => NmeaTransport.RESERVED_CHARACTERS.includes(c)))
            throw new DecodeException(`Invalid character found in address field: ${address}`);
        try {
            for (let i = 1; i < elements.length; i++)
                elements[i] = unescape(elements[i]);
        }
        catch (err) {
            throw new DecodeException(`Invalid field detected: ${err.message}`);
        }
        const talker = address.slice(0, -3);
        const sentenceType = address.slice(-3);
        if (address.length == 5 && sentenceDelimiter === NmeaTransport.SENTENCE_DELIMITER_PARAMETRIC
            && sentenceType.endsWith(NmeaTransport.QUERY_ADDRESS_CHARACTER)) {
            const queriedTalker = sentenceType.slice(0, 2);
            return NmeaMessageQuery.construct({
                talker: talker,
                queriedTalker: queriedTalker,
                queriedSentenceType: elements[0]
            });
        }
        const resultType = nmeaMessageClasses.get(sentenceType);
        if (resultType === undefined || talker === talkers_1.NmeaTalker.PROPRIETARY_CODE) {
            return (talker === talkers_1.NmeaTalker.PROPRIETARY_CODE ?
                NmeaMessageProprietary : NmeaMessageUnknown).construct({
                talker: talker,
                unknownSentenceType: sentenceType,
                unknownSentenceDelimiter: sentenceDelimiter,
                elements: elements
            });
        }
        const message = new resultType(undefined);
        if (message.sentenceDelimiter !== sentenceDelimiter)
            throw new DecodeException(`Invalid sentence delimiter for sentence type ${message.sentenceType}`);
        message.talker = talker;
        const decoder = decode_encode_1.getDecoderEncoder(message.constructor).decoder;
        try {
            decoder.run(message, elements, 1);
        }
        catch (err) {
            throw new DecodeException(`Could not run script: ${err.message}}\n${decoder.fullScript}`);
        }
        return message;
    }
    NmeaTransport.decode = decode;
    function encode(message) {
        const sentenceDelimiter = message.sentenceDelimiter;
        if (sentenceDelimiter != NmeaTransport.SENTENCE_DELIMITER_PARAMETRIC && sentenceDelimiter != NmeaTransport.SENTENCE_DELIMITER_ENCAPSULATION)
            throw new DecodeException(`Invalid delimiter (expected ${NmeaTransport.SENTENCE_DELIMITER_PARAMETRIC} or ${NmeaTransport.SENTENCE_DELIMITER_ENCAPSULATION}, got ${sentenceDelimiter})`);
        const address = message.talker + message.sentenceType;
        if (address.length < 4 || address.length > 5)
            throw new EncodeException(`Invalid address field length: ${address}`);
        if (address.split('').some(c => NmeaTransport.RESERVED_CHARACTERS.includes(c)))
            throw new DecodeException(`Invalid character found in address field: ${address}`);
        const elements = [address];
        const encoder = decode_encode_1.getDecoderEncoder(message.constructor).encoder;
        try {
            encoder.run(message, elements, 1);
        }
        catch (err) {
            throw new EncodeException(`Could not run script: ${err.message}\n${encoder.fullScript}`);
        }
        for (let i = 1; i < elements.length; i++)
            elements[i] = escape(elements[i]);
        const messageContent = elements.join(NmeaTransport.DATA_FIELD_DELIMITER);
        const checksumCalculated = checksum(messageContent);
        return message.sentenceDelimiter
            + messageContent
            + NmeaTransport.CHECKSUM_FIELD_DELIMITER
            + checksumCalculated
            + NmeaTransport.SENTENCE_TERMINATION_SEQUENCE;
    }
    NmeaTransport.encode = encode;
    function checksum(sentence) {
        let checksum = 0;
        for (let i = 0; i < sentence.length; i++)
            checksum ^= sentence.charCodeAt(i);
        return (checksum & 0xff).toString(16).toUpperCase().padStart(2, '0');
    }
    NmeaTransport.checksum = checksum;
    function escape(field) {
        for (let i = 0; i < field.length; i++) {
            const char = field.charAt(i);
            const charCode = field.charCodeAt(i);
            if (charCode >= 0x20 && charCode <= 0x7f && !NmeaTransport.RESERVED_CHARACTERS.includes(char))
                continue;
            field = field.slice(0, i)
                + NmeaTransport.CODE_DELIMITER
                + charCode.toString(16).toUpperCase().padStart(2, '0')
                + field.slice(i + 1);
            i += 2;
        }
        return field;
    }
    NmeaTransport.escape = escape;
    function unescape(field) {
        for (let i = 0; i < field.length; i++) {
            const char = field.charAt(i);
            const charCode = field.charCodeAt(i);
            if (charCode >= 0x20 && charCode <= 0x7f && !NmeaTransport.RESERVED_CHARACTERS.includes(char))
                continue;
            if (char !== NmeaTransport.CODE_DELIMITER)
                throw new Error(`Illegal character found at index ${i} in: ${field}`);
            const unescapedCharCodeHex = field.slice(i + 1, i + 3);
            if (!/[0-9A-Fa-f]{2}/.test(unescapedCharCodeHex))
                throw new Error(`Code delimiter found without corresponding hex code at index ${i} in: ${field}`);
            const unescapedCharCode = parseInt(unescapedCharCodeHex, 16);
            field = field.slice(0, i)
                + String.fromCharCode(unescapedCharCode)
                + field.slice(i + 3);
        }
        return field;
    }
    NmeaTransport.unescape = unescape;
})(NmeaTransport = exports.NmeaTransport || (exports.NmeaTransport = {}));
require("./messages/index");
