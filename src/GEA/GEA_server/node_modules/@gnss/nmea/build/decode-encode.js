"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Unit = exports.CompleteDateTime = exports.FullDate = exports.ShortDate = exports.Time = exports.Lng = exports.Lat = exports.Mag = exports.Arr = exports.Obj = exports.Str = exports.Chars = exports.PadHex = exports.PadInt = exports.Hex = exports.Float = exports.Int = exports.getDecoderEncoder = exports.DecoderEncoder = exports.Helpers = void 0;
require("reflect-metadata");
class Coder {
    constructor(parent) {
        this.parent = parent;
        this.definitions = Coder.definitions;
        this.lines = [];
    }
    static define(definition) {
        return `this.definitions[${Coder.definitions.push(definition) - 1}]`;
    }
    code(...code) {
        this.lines.push(...code);
    }
    set(prop, code) {
        this.code(`o.${prop} = ${code}`);
    }
    get fullLines() {
        var _a, _b;
        return [...(_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.fullLines) !== null && _b !== void 0 ? _b : [], ...this.lines];
    }
    get fullScript() {
        return this.fullLines.join('\n') + '\n';
    }
    run(o, e, i) {
        if (this.compiled === undefined)
            this.compiled = new Function('o', 'e', 'i', this.lines.join('\n') + 'return [o, i];');
        return this.compiled(o, e, i);
    }
}
Coder.definitions = [];
var Helpers;
(function (Helpers) {
    let Float;
    (function (Float) {
        function decode(val) {
            const number = parseFloat(val);
            if (isNaN(number))
                return undefined;
            return number;
        }
        Float.decode = decode;
        function encode(val) {
            var _a;
            return (_a = val === null || val === void 0 ? void 0 : val.toString()) !== null && _a !== void 0 ? _a : '';
        }
        Float.encode = encode;
    })(Float = Helpers.Float || (Helpers.Float = {}));
    let Int;
    (function (Int) {
        function decode(val) {
            const number = parseInt(val);
            if (isNaN(number))
                return undefined;
            return number;
        }
        Int.decode = decode;
        function encode(val, pad = 0) {
            if (val === undefined)
                return '';
            const result = Math.abs(val).toString().padStart(pad, "0");
            return (val < 0 ? '-' : '') + result;
        }
        Int.encode = encode;
    })(Int = Helpers.Int || (Helpers.Int = {}));
    let Hex;
    (function (Hex) {
        function decode(val) {
            const number = parseInt(val, 16);
            if (isNaN(number))
                return undefined;
            return number;
        }
        Hex.decode = decode;
        function encode(val, pad = 0) {
            if (val === undefined)
                return '';
            const result = Math.abs(val).toString(16).toUpperCase().padStart(pad, "0");
            return (val < 0 ? '-' : '') + result;
        }
        Hex.encode = encode;
    })(Hex = Helpers.Hex || (Helpers.Hex = {}));
    let String;
    (function (String) {
        function decode(val) {
            return val || undefined;
        }
        String.decode = decode;
        function encode(val) {
            return val !== null && val !== void 0 ? val : '';
        }
        String.encode = encode;
    })(String = Helpers.String || (Helpers.String = {}));
    let Chars;
    (function (Chars) {
        function decode(val) {
            if (val.length === 0)
                return undefined;
            return val.split('');
        }
        Chars.decode = decode;
        function encode(val) {
            if (val === undefined)
                return '';
            return val.join('');
        }
        Chars.encode = encode;
    })(Chars = Helpers.Chars || (Helpers.Chars = {}));
    let Direction;
    (function (Direction) {
        function decode(val, pos, neg) {
            return val !== neg ? 1 : -1;
        }
        Direction.decode = decode;
        function encode(val, pos, neg) {
            if (val === undefined)
                return '';
            return val >= 0 ? pos : neg;
        }
        Direction.encode = encode;
    })(Direction = Helpers.Direction || (Helpers.Direction = {}));
    let Time;
    (function (Time) {
        function decode(val) {
            if (val.length === 0)
                return undefined;
            const date = new Date(0, 0, 0);
            date.setUTCHours(Number(val.substr(0, 2)));
            date.setUTCMinutes(Number(val.substr(2, 2)));
            date.setUTCSeconds(Number(val.substr(4, 2)));
            date.setUTCMilliseconds(parseFloat('0' + val.substr(6)));
            return date;
        }
        Time.decode = decode;
        function encode(val) {
            if (val === undefined)
                return '';
            return val.getUTCHours().toString().padStart(2, "0")
                + val.getUTCMinutes().toString().padStart(2, "0")
                + val.getUTCSeconds().toString().padStart(2, "0")
                + (val.getUTCMilliseconds() / 1000).toFixed(2).substr(1);
        }
        Time.encode = encode;
    })(Time = Helpers.Time || (Helpers.Time = {}));
    let ShortDate;
    (function (ShortDate) {
        function decode(val) {
            if (val.length === 0)
                return undefined;
            const date = new Date();
            date.setUTCDate(Number(val.substr(0, 2)));
            date.setUTCMonth(Number(val.substr(2, 2)));
            const year = Number(val.substr(4));
            date.setUTCFullYear(year > 100 ? year : (year < 70 ? 2000 : 1900) + year);
            date.setUTCHours(0, 0, 0, 0);
            return date;
        }
        ShortDate.decode = decode;
        function encode(val) {
            if (val === undefined)
                return '';
            return val.getUTCDate().toString().padStart(2, "0")
                + val.getUTCMonth().toString().padStart(2, "0")
                + val.getUTCFullYear().toString().substr(2).padStart(2, "0");
        }
        ShortDate.encode = encode;
    })(ShortDate = Helpers.ShortDate || (Helpers.ShortDate = {}));
    let FullDate;
    (function (FullDate) {
        function decode(val) {
            if (val.length === 0)
                return undefined;
            const date = new Date();
            date.setUTCDate(Number(val.substr(0, 2)));
            date.setUTCMonth(Number(val.substr(2, 2)));
            date.setUTCFullYear(Number(val.substr(4)));
            date.setUTCHours(0, 0, 0, 0);
            return date;
        }
        FullDate.decode = decode;
        function encode(val) {
            if (val === undefined)
                return '';
            return val.getUTCDate().toString().padStart(2, "0")
                + val.getUTCMonth().toString().padStart(2, "0")
                + val.getUTCFullYear().toString();
        }
        FullDate.encode = encode;
    })(FullDate = Helpers.FullDate || (Helpers.FullDate = {}));
    let CompleteDateTime;
    (function (CompleteDateTime) {
        function decode(time, day, month, year) {
            if (time.length === 0 || day.length === 0 || month.length === 0 || year.length === 0)
                return undefined;
            const date = Helpers.Time.decode(time);
            date.setUTCDate(parseInt(day));
            date.setUTCMonth(parseInt(month));
            date.setUTCFullYear(parseInt(year));
            return date;
        }
        CompleteDateTime.decode = decode;
        function encode(val) {
            if (val === undefined)
                return ['', '', '', ''];
            return [
                Helpers.Time.encode(val),
                val.getUTCDate().toString().padStart(2, "0"),
                val.getUTCMonth().toString().padStart(2, "0"),
                val.getUTCFullYear().toString()
            ];
        }
        CompleteDateTime.encode = encode;
    })(CompleteDateTime = Helpers.CompleteDateTime || (Helpers.CompleteDateTime = {}));
    let Latitude;
    (function (Latitude) {
        function decode(lat) {
            if (lat.length === 0)
                return undefined;
            const decimal = lat.length - lat.indexOf('.');
            return (parseInt(lat.slice(0, -decimal - 2)) + (parseFloat(lat.slice(-decimal - 2)) / 60));
        }
        Latitude.decode = decode;
        function encode(lat) {
            if (lat === undefined)
                return '';
            lat = Math.abs(lat);
            const degrees = Math.floor(lat);
            const minutes = (lat - degrees) * 60;
            return degrees.toString().padStart(2, "0") + minutes.toFixed(2).padStart(5, "0");
        }
        Latitude.encode = encode;
    })(Latitude = Helpers.Latitude || (Helpers.Latitude = {}));
    let Longitude;
    (function (Longitude) {
        function decode(lng, ew) {
            if (lng.length === 0)
                return undefined;
            const decimal = lng.length - lng.indexOf('.');
            return (parseInt(lng.slice(0, -decimal - 2)) + (parseFloat(lng.slice(-decimal - 2)) / 60));
        }
        Longitude.decode = decode;
        function encode(lng) {
            if (lng === undefined)
                return '';
            lng = Math.abs(lng);
            const degrees = Math.floor(lng);
            const minutes = (lng - degrees) * 60;
            return degrees.toString().padStart(3, "0") + minutes.toFixed(2).padStart(5, "0");
        }
        Longitude.encode = encode;
    })(Longitude = Helpers.Longitude || (Helpers.Longitude = {}));
})(Helpers = exports.Helpers || (exports.Helpers = {}));
class DecoderEncoder {
    constructor(parent) {
        this.parent = parent;
        this.encoder = new Coder(parent === null || parent === void 0 ? void 0 : parent.encoder);
        this.decoder = new Coder(parent === null || parent === void 0 ? void 0 : parent.decoder);
    }
    array(prop, count) {
        let limit = typeof count === 'number' ? count : `o.${count}`;
        this.decoder.set(prop, `[]`);
        this.decoder.code(`for (let j = 0; j < ${limit}; j++)`);
        this.encoder.code(`for (let j = 0; j < ${limit}; j++) if (o.${prop} === undefined) e[i++] = ''; else`);
    }
    object(prop, constructor) {
        const ode = getDecoderEncoder(constructor);
        const constructorDef = Coder.define(constructor);
        const odeDef = Coder.define(ode);
        this.decoder.code(`[o.${prop}, i] = ${odeDef}.decoder.run(new ${constructorDef}(), e, i);`);
        this.encoder.code(`[, i] = ${odeDef}.encoder.run(o.${prop}, e, i);`);
    }
    apply(prop, helper, count = 1, ...args) {
        const elements = new Array(count).fill('e[i++]').join(',');
        const decodeArgs = [elements, ...args].join(',');
        this.decoder.set(prop, `${DecoderEncoder.helpers}.${helper}.decode(${decodeArgs});`);
        const encodeArgs = [`o.${prop}`, ...args].join(',');
        this.encoder.code(`${count > 1 ? '[' + elements + ']' : elements} = ${DecoderEncoder.helpers}.${helper}.encode(${encodeArgs});`);
    }
    directional(prop, helper, positive, negative) {
        this.decoder.code(`{`, `\to.${prop} = ${DecoderEncoder.helpers}.${helper}.decode(e[i++]);`, `\tif (o.${prop} !== undefined)`, `\t\to.${prop} *= ${DecoderEncoder.helpers}.Direction.decode(e[i++], "${positive}", "${negative}");`, `}`);
        this.encoder.code(`{`, `e[i++] = ${DecoderEncoder.helpers}.${helper}.encode(o.${prop});`, `e[i++] = ${DecoderEncoder.helpers}.Direction.encode(o.${prop}, "${positive}", "${negative}");`, `}`);
    }
    unit(prop, val) {
        this.decoder.code('i++;');
        this.encoder.code(`e[i++] = o.${prop} !== undefined ? '${val}' : '';`);
    }
}
exports.DecoderEncoder = DecoderEncoder;
DecoderEncoder.helpers = Coder.define(Helpers);
const decoderEncoderKey = Symbol('decoderEncoder');
function getDecoderEncoder(target) {
    const c = (target.hasOwnProperty('constructor') ? target.constructor : target);
    if (!Reflect.hasOwnMetadata(decoderEncoderKey, c))
        Reflect.defineMetadata(decoderEncoderKey, new DecoderEncoder(Reflect.getMetadata(decoderEncoderKey, c)), c);
    return Reflect.getMetadata(decoderEncoderKey, c);
}
exports.getDecoderEncoder = getDecoderEncoder;
function propertyDecorator(f) {
    return function (target, propertyKey, descriptor) {
        let read = descriptor === undefined || descriptor.set !== undefined;
        let write = descriptor === undefined || descriptor.get !== undefined;
        f(getDecoderEncoder(target), propertyKey, read, write);
    };
}
function propertyDecoratorApply(helper, count, ...args) {
    return propertyDecorator((de, key) => de.apply(key, helper, count, args));
}
function propertyDecoratorDirectional(helper, positive, negative) {
    return propertyDecorator((de, key) => de.directional(key, helper, positive, negative));
}
exports.Int = propertyDecoratorApply('Int');
exports.Float = propertyDecoratorApply('Float');
exports.Hex = propertyDecoratorApply('Hex');
const PadInt = (pad) => propertyDecoratorApply('Int', 1, pad);
exports.PadInt = PadInt;
const PadHex = (pad) => propertyDecoratorApply('Hex', 1, pad);
exports.PadHex = PadHex;
exports.Chars = propertyDecoratorApply('Chars');
exports.Str = propertyDecoratorApply('String');
const Obj = (constructor) => propertyDecorator((de, key) => de.object(key, constructor));
exports.Obj = Obj;
function Arr(length, type) {
    return function (target, propertyKey) {
        getDecoderEncoder(target).array(propertyKey, length);
        type(target, propertyKey + '[j]');
    };
}
exports.Arr = Arr;
exports.Mag = propertyDecoratorDirectional('Float', 'W', 'E');
exports.Lat = propertyDecoratorDirectional('Latitude', 'N', 'S');
exports.Lng = propertyDecoratorDirectional('Longitude', 'E', 'W');
exports.Time = propertyDecoratorApply('Time');
exports.ShortDate = propertyDecoratorApply('ShortDate');
exports.FullDate = propertyDecoratorApply('FullDate');
exports.CompleteDateTime = propertyDecoratorApply('CompleteDateTime', 4);
const Unit = (unit) => propertyDecorator((de, key) => de.unit(key, unit));
exports.Unit = Unit;
