"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NmeaEncodeTransformStream = exports.NmeaDecodeTransformStream = void 0;
const stream = require("stream");
const nmea_1 = require("./nmea");
function indexOfLimited(string, search, fromIndex, toIndex) {
    const index = string.indexOf(search, fromIndex);
    return (index >= toIndex) ? -1 : index;
}
class NmeaDecodeTransformStream extends stream.Transform {
    constructor({ closeOnError = true, synchronizedInitially = false } = {}) {
        super({
            readableObjectMode: true,
            writableObjectMode: false
        });
        this.buffer = Buffer.allocUnsafe(nmea_1.NmeaTransport.MAX_SENTENCE_SIZE);
        this.index = 0;
        this.synchronized = false;
        this.potential = false;
        this.closeOnError = false;
        this.closeOnError = closeOnError;
        this.synchronized = synchronizedInitially;
    }
    static nextSentenceDelimiter(buffer, startIndex = 0, endIndex = buffer.length) {
        let parametricDelimiterIndex = indexOfLimited(buffer, nmea_1.NmeaTransport.SENTENCE_DELIMITER_PARAMETRIC, startIndex, endIndex);
        let encapsulationDelimiterIndex = indexOfLimited(buffer, nmea_1.NmeaTransport.SENTENCE_DELIMITER_ENCAPSULATION, startIndex, endIndex);
        if (parametricDelimiterIndex === -1)
            return encapsulationDelimiterIndex;
        if (encapsulationDelimiterIndex === -1)
            return parametricDelimiterIndex;
        return Math.min(parametricDelimiterIndex, encapsulationDelimiterIndex);
    }
    _transform(chunk, encoding, callback) {
        if (typeof chunk === 'string')
            chunk = Buffer.from(chunk, encoding);
        let chunkOffset = 0;
        while (chunk.length - chunkOffset > 0) {
            if (!this.potential && !this.synchronized) {
                const potential = NmeaDecodeTransformStream.nextSentenceDelimiter(chunk, chunkOffset);
                if (potential < 0)
                    return callback();
                this.potential = true;
                chunkOffset = potential;
            }
            const copyBytes = Math.min(chunk.length - chunkOffset, this.buffer.length - this.index);
            chunk.copy(this.buffer, this.index, chunkOffset, chunkOffset + copyBytes);
            this.index += copyBytes;
            chunkOffset += copyBytes;
            do {
                try {
                    if (NmeaDecodeTransformStream.nextSentenceDelimiter(this.buffer, 0, 1) !== 0)
                        nmea_1.NmeaTransport.decode(this.buffer.toString('ascii', 0, 1));
                    const packetLength = indexOfLimited(this.buffer, nmea_1.NmeaTransport.SENTENCE_TERMINATION_SEQUENCE, 0, this.index);
                    if (packetLength < 0)
                        break;
                    const message = nmea_1.NmeaTransport.decode(this.buffer.toString('ascii', 0, packetLength));
                    this.buffer.copyWithin(0, packetLength + nmea_1.NmeaTransport.SENTENCE_TERMINATION_SEQUENCE.length);
                    this.index -= packetLength + nmea_1.NmeaTransport.SENTENCE_TERMINATION_SEQUENCE.length;
                    this.potential = false;
                    this.synchronized = true;
                    this.push(message);
                    if (this.index === 0)
                        break;
                }
                catch (err) {
                    if (this.synchronized && this.closeOnError)
                        return callback(err);
                    this.synchronized = false;
                    this.potential = false;
                    const potential = NmeaDecodeTransformStream.nextSentenceDelimiter(this.buffer, 1, this.index);
                    if (potential < 0) {
                        this.index = 0;
                        break;
                    }
                    this.potential = true;
                    this.buffer.copyWithin(0, potential);
                    this.index -= potential;
                }
            } while (true);
            if (this.index === this.buffer.length)
                this.index = 0;
        }
        return callback();
    }
}
exports.NmeaDecodeTransformStream = NmeaDecodeTransformStream;
class NmeaEncodeTransformStream extends stream.Transform {
    constructor() {
        super({
            readableObjectMode: false,
            writableObjectMode: true
        });
    }
    _transform(message, encoding, callback) {
        try {
            callback(null, nmea_1.NmeaTransport.encode(message));
        }
        catch (err) {
            callback(err);
        }
    }
}
exports.NmeaEncodeTransformStream = NmeaEncodeTransformStream;
